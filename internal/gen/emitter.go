package gen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"go/types"
	"path"
	"slices"
	"sort"
	"strings"

	"github.com/mickamy/injector/internal/config"
	"github.com/mickamy/injector/internal/prints"
	"github.com/mickamy/injector/internal/resolve"
)

type Container struct {
	// Name is the struct type name.
	Name string
	// Fields are container fields (including "_" override fields which will be ignored in the final struct literal).
	Fields []resolve.ContainerField
	// Providers is the list of providers in execution order (dependencies first).
	Providers []*resolve.Provider
	// PkgPath is used to decide whether a provider call needs an import qualifier.
	PkgPath string
	// FuncName is the generated constructor function name.
	FuncName string
}

type EmitInput struct {
	// PackageName is the target package name where the container lives.
	PackageName string
	OnError     *config.OnError
	Containers  []Container
}

func (ei EmitInput) Append(c Container) EmitInput {
	return EmitInput{
		PackageName: ei.PackageName,
		Containers:  append(ei.Containers, c),
	}
}

func EmitContainers(in EmitInput) ([]byte, error) {
	if in.PackageName == "" {
		return nil, fmt.Errorf("gen: PackageName is required")
	}
	for _, c := range in.Containers {
		if c.Name == "" {
			return nil, fmt.Errorf("gen: Container.Name is required")
		}
		if c.FuncName == "" {
			c.FuncName = "New" + c.Name
		}
	}

	aliases := make(map[string]string)
	importLog := in.OnError != nil && in.OnError.String() == config.OnErrorFatal.String()
	for _, c := range in.Containers {
		err := buildImportAliases(aliases, c.PkgPath, c.Providers, importLog)
		if err != nil {
			return nil, fmt.Errorf("gen: failed to build import aliases: %v", err)
		}
	}

	var buf bytes.Buffer
	prints.Fprint(&buf, "// Code generated by injector. DO NOT EDIT.\n\n")
	prints.Fprintf(&buf, "package %s\n\n", in.PackageName)

	imports := sortedImports(aliases)
	if len(imports) > 0 || importLog {
		buf.WriteString("import (\n")
		if importLog {
			prints.Fprintf(&buf, "\t%q\n\n", "log")
		}
		for _, imp := range imports {
			prints.Fprintf(&buf, "\t%s %q\n", aliases[imp], imp)
		}
		buf.WriteString(")\n\n")
	}

	for _, c := range in.Containers {
		if err := writeNewFunc(&buf, c, aliases, nil); err != nil {
			return nil, fmt.Errorf("gen: failed to write: %v", err)
		}
		if in.OnError != nil {
			if err := writeNewFunc(&buf, c, aliases, in.OnError); err != nil {
				return nil, fmt.Errorf("gen: failed to write must: %v", err)
			}
		}
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("gen: format: %w", err)
	}
	return src, nil
}

func writeNewFunc(buf *bytes.Buffer, c Container, aliases map[string]string, onError *config.OnError) error {
	// Build local variable plan: typeKey -> varName
	varByType := map[string]string{}

	returnErr := slices.ContainsFunc(c.Providers, func(provider *resolve.Provider) bool {
		return provider.ReturnError
	}) && onError == nil

	must := onError != nil

	funcName := c.FuncName
	doc := fmt.Sprintf("%s initializes dependencies and constructs %s.", funcName, c.Name)
	if must {
		funcName = fmt.Sprintf("Must%s", funcName)
		doc = fmt.Sprintf("%s initializes dependencies and constructs %s or %s on failure.", funcName, c.Name, onError.Behavior())
	}
	prints.Fprintf(buf, "// %s\n", doc)

	returnType := c.Name
	var hasPointer bool
	for _, field := range c.Fields {
		if isPointer(field.Type) {
			hasPointer = true
			break
		}
	}
	if hasPointer {
		returnType = fmt.Sprintf("*%s", returnType)
	}

	if must {
		prints.Fprintf(buf, "func %s() %s {\n", funcName, returnType)
	} else {
		prints.Fprintf(buf, "func %s() (%s, error) {\n", funcName, returnType)
	}

	for _, p := range c.Providers {
		if p == nil {
			continue
		}

		call := providerCallExpr(c.PkgPath, aliases, p)

		var args []string
		for _, pt := range p.Params {
			key := typeKey(pt)
			v, ok := varByType[key]
			if !ok {
				return fmt.Errorf(
					"missing resolved value for param %s (required by %s)",
					typeString(pt),
					providerString(p),
				)
			}
			args = append(args, v)
		}

		resKey := typeKey(p.ResultType)
		vname, err := varNameForResult(p.Name, varByType)
		if err != nil {
			return err
		}

		if p.ReturnError {
			prints.Fprintf(buf, "\t%s, err := %s(%s)\n", vname, call, strings.Join(args, ", "))
			prints.Fprint(buf, "\tif err != nil {\n")
			if must {
				prints.Fprintf(buf, "\t\t%s(err)\n", onError.Func())
			} else {
				prints.Fprint(buf, "\t\treturn nil, err\n")
			}
			prints.Fprint(buf, "\t}\n")
		} else {
			prints.Fprintf(buf, "\t%s := %s(%s)\n", vname, call, strings.Join(args, ", "))
		}
		varByType[resKey] = vname
	}

	buf.WriteString("\n\treturn &")
	buf.WriteString(c.Name)
	buf.WriteString("{\n")

	for _, f := range c.Fields {
		if f.Name == "_" {
			continue
		}

		key := typeKey(f.Type)
		v, ok := varByType[key]
		if !ok {
			return fmt.Errorf("gen: missing resolved value for field %s (%s)", f.Name, typeString(f.Type))
		}

		prints.Fprintf(buf, "\t\t%s: %s,\n", f.Name, v)
	}

	if returnErr {
		buf.WriteString("\t}, nil\n")
		buf.WriteString("}\n")
	} else {
		buf.WriteString("\t}\n")
		buf.WriteString("}\n")
	}

	return nil
}

func buildImportAliases(aliases map[string]string, containerPkgPath string, providers []*resolve.Provider, importLog bool) error {
	used := make(map[string]struct{})
	for _, a := range aliases {
		used[a] = struct{}{}
	}
	if importLog {
		used["log"] = struct{}{}
	}

	for _, p := range providers {
		if p == nil || p.PkgPath == "" {
			continue
		}
		if p.PkgPath == containerPkgPath {
			continue
		}

		base := path.Base(p.PkgPath)
		if base == "" || base == "." || base == "/" {
			return fmt.Errorf("invalid provider package path %q for %s", p.PkgPath, providerString(p))
		}
		alias := base

		if _, ok := aliases[p.PkgPath]; ok {
			continue
		}

		if _, ok := used[alias]; ok {
			for i := 2; ; i++ {
				try := fmt.Sprintf("%s%d", base, i)
				if _, ok := used[try]; !ok {
					alias = try
					break
				}
			}
		}

		aliases[p.PkgPath] = alias
		used[alias] = struct{}{}
	}

	return nil
}

func sortedImports(aliases map[string]string) []string {
	if len(aliases) == 0 {
		return nil
	}
	out := make([]string, 0, len(aliases))
	for imp := range aliases {
		out = append(out, imp)
	}
	sort.Strings(out)
	return out
}

func providerCallExpr(containerPkgPath string, aliases map[string]string, p *resolve.Provider) string {
	if p == nil {
		return ""
	}
	if p.PkgPath == "" || p.PkgPath == containerPkgPath {
		return p.Name
	}
	alias := aliases[p.PkgPath]
	if alias == "" {
		alias = path.Base(p.PkgPath)
	}
	return alias + "." + p.Name
}

func varNameForResult(providerName string, existing map[string]string) (string, error) {
	base := providerName
	if strings.HasPrefix(base, "New") && len(base) > 3 {
		base = base[3:]
	}
	base = lowerFirst(base)
	if base == "" {
		return "", errors.New("empty variable name")
	}

	used := map[string]bool{}
	for _, v := range existing {
		used[v] = true
	}
	if !used[base] {
		return base, nil
	}
	for i := 2; ; i++ {
		try := fmt.Sprintf("%s%d", base, i)
		if !used[try] {
			return try, nil
		}
	}
}

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func typeKey(t types.Type) string {
	return types.TypeString(t, func(p *types.Package) string {
		if p == nil {
			return ""
		}
		return p.Path()
	})
}

func typeString(t types.Type) string {
	return types.TypeString(t, func(p *types.Package) string {
		if p == nil {
			return ""
		}
		return p.Path()
	})
}

func providerString(p *resolve.Provider) string {
	if p == nil {
		return "<nil>"
	}
	if p.PkgPath == "" {
		return p.Name
	}
	return p.PkgPath + "." + p.Name
}

func isPointer(t types.Type) bool {
	_, ok := t.(*types.Pointer)
	return ok
}
