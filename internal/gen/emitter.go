package gen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"go/types"
	"path"
	"slices"
	"sort"
	"strings"

	"github.com/mickamy/injector/internal/prints"
	"github.com/mickamy/injector/internal/resolve"
)

type EmitInput struct {
	// PackageName is the target package name where the container lives.
	PackageName string
	// ContainerName is the struct type name.
	ContainerName string
	// Fields are container fields (including "_" override fields which will be ignored in the final struct literal).
	Fields []resolve.ContainerField
	// Providers is the list of providers in execution order (dependencies first).
	Providers []*resolve.Provider
	// ContainerPkgPath is used to decide whether a provider call needs an import qualifier.
	ContainerPkgPath string
	// FuncName is the generated constructor function name.
	FuncName string
}

func EmitContainer(in EmitInput) ([]byte, error) {
	if in.PackageName == "" {
		return nil, fmt.Errorf("gen: PackageName is required")
	}
	if in.ContainerName == "" {
		return nil, fmt.Errorf("gen: ContainerName is required")
	}
	if in.FuncName == "" {
		in.FuncName = "New" + in.ContainerName
	}

	aliases, err := buildImportAliases(in.ContainerPkgPath, in.Providers)
	if err != nil {
		return nil, fmt.Errorf("gen: %w", err)
	}

	var buf bytes.Buffer
	prints.Fprint(&buf, "// Code generated by injector. DO NOT EDIT.\n\n")
	prints.Fprintf(&buf, "package %s\n\n", in.PackageName)

	imports := sortedImports(aliases)
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range imports {
			prints.Fprintf(&buf, "\t%s %q\n", aliases[imp], imp)
		}
		buf.WriteString(")\n\n")
	}

	// Build local variable plan: typeKey -> varName
	varByType := map[string]string{}

	returnErr := slices.ContainsFunc(in.Providers, func(provider *resolve.Provider) bool {
		return provider.ReturnError
	})

	prints.Fprintf(&buf, "// %s initializes dependencies and constructs %s.\n", in.FuncName, in.ContainerName)
	if returnErr {
		prints.Fprintf(&buf, "func %s() (*%s, error) {\n", in.FuncName, in.ContainerName)
	} else {
		prints.Fprintf(&buf, "func %s() *%s {\n", in.FuncName, in.ContainerName)
	}

	for _, p := range in.Providers {
		if p == nil {
			continue
		}

		call := providerCallExpr(in.ContainerPkgPath, aliases, p)

		var args []string
		for _, pt := range p.Params {
			key := typeKey(pt)
			v, ok := varByType[key]
			if !ok {
				return nil, fmt.Errorf(
					"gen: missing resolved value for param %s (required by %s)",
					typeString(pt),
					providerString(p),
				)
			}
			args = append(args, v)
		}

		resKey := typeKey(p.ResultType)
		vname, err := varNameForResult(p.Name, varByType)
		if err != nil {
			return nil, fmt.Errorf("gen: %w", err)
		}

		if p.ReturnError {
			prints.Fprintf(&buf, "\t%s, err := %s(%s)\n", vname, call, strings.Join(args, ", "))
			prints.Fprint(&buf, "\tif err != nil {\n")
			prints.Fprint(&buf, "\t\treturn nil, err\n")
			prints.Fprint(&buf, "\t}\n")
		} else {
			prints.Fprintf(&buf, "\t%s := %s(%s)\n", vname, call, strings.Join(args, ", "))
		}
		varByType[resKey] = vname
	}

	buf.WriteString("\n\treturn &")
	buf.WriteString(in.ContainerName)
	buf.WriteString("{\n")

	for _, f := range in.Fields {
		if f.Name == "_" {
			continue
		}

		key := typeKey(f.Type)
		v, ok := varByType[key]
		if !ok {
			return nil, fmt.Errorf("gen: missing resolved value for field %s (%s)", f.Name, typeString(f.Type))
		}

		prints.Fprintf(&buf, "\t\t%s: %s,\n", f.Name, v)
	}

	if returnErr {
		buf.WriteString("\t}, nil\n")
		buf.WriteString("}\n")
	} else {
		buf.WriteString("\t}\n")
		buf.WriteString("}\n")
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("gen: format: %w", err)
	}
	return src, nil
}

func buildImportAliases(containerPkgPath string, providers []*resolve.Provider) (map[string]string, error) {
	used := map[string]bool{}
	out := map[string]string{}

	for _, p := range providers {
		if p == nil || p.PkgPath == "" {
			continue
		}
		if p.PkgPath == containerPkgPath {
			continue
		}

		base := path.Base(p.PkgPath)
		if base == "" || base == "." || base == "/" {
			return nil, fmt.Errorf("invalid provider package path %q for %s", p.PkgPath, providerString(p))
		}
		alias := base

		if used[alias] {
			for i := 2; ; i++ {
				try := fmt.Sprintf("%s%d", base, i)
				if !used[try] {
					alias = try
					break
				}
			}
		}

		used[alias] = true
		out[p.PkgPath] = alias
	}

	return out, nil
}

func sortedImports(aliases map[string]string) []string {
	if len(aliases) == 0 {
		return nil
	}
	out := make([]string, 0, len(aliases))
	for imp := range aliases {
		out = append(out, imp)
	}
	sort.Strings(out)
	return out
}

func providerCallExpr(containerPkgPath string, aliases map[string]string, p *resolve.Provider) string {
	if p == nil {
		return ""
	}
	if p.PkgPath == "" || p.PkgPath == containerPkgPath {
		return p.Name
	}
	alias := aliases[p.PkgPath]
	if alias == "" {
		alias = path.Base(p.PkgPath)
	}
	return alias + "." + p.Name
}

func varNameForResult(providerName string, existing map[string]string) (string, error) {
	base := providerName
	if strings.HasPrefix(base, "New") && len(base) > 3 {
		base = base[3:]
	}
	base = lowerFirst(base)
	if base == "" {
		return "", errors.New("empty variable name")
	}

	used := map[string]bool{}
	for _, v := range existing {
		used[v] = true
	}
	if !used[base] {
		return base, nil
	}
	for i := 2; ; i++ {
		try := fmt.Sprintf("%s%d", base, i)
		if !used[try] {
			return try, nil
		}
	}
}

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func typeKey(t types.Type) string {
	return types.TypeString(t, func(p *types.Package) string {
		if p == nil {
			return ""
		}
		return p.Path()
	})
}

func typeString(t types.Type) string {
	return types.TypeString(t, func(p *types.Package) string {
		if p == nil {
			return ""
		}
		return p.Path()
	})
}

func providerString(p *resolve.Provider) string {
	if p == nil {
		return "<nil>"
	}
	if p.PkgPath == "" {
		return p.Name
	}
	return p.PkgPath + "." + p.Name
}
